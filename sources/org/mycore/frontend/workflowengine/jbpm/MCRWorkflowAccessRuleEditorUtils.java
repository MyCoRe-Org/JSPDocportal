/**
 * $RCSfile$
 * $Revision$ $Date$
 *
 * This file is part of ** M y C o R e **
 * Visit our homepage at http://www.mycore.de/ for details.
 *
 * This program is free software; you can use it, redistribute it
 * and / or modify it under the terms of the GNU General Public License
 * (GPL) as published by the Free Software Foundation; either version 2
 * of the License or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program, normally in the file license.txt.
 * If not, write to the Free Software Foundation Inc.,
 * 59 Temple Place - Suite 330, Boston, MA  02111-1307 USA
 *
 **/

package org.mycore.frontend.workflowengine.jbpm;

import java.io.IOException;
import java.io.StringReader;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.PropertyResourceBundle;

import javax.servlet.jsp.JspWriter;

import org.apache.log4j.Logger;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;
import org.jdom.xpath.XPath;

import org.mycore.access.MCRAccessInterface;
import org.mycore.access.MCRAccessManager;
import org.mycore.access.mcrimpl.MCRAccessControlSystem;
import org.mycore.access.mcrimpl.MCRAccessRule;
import org.mycore.access.mcrimpl.MCRAccessStore;
import org.mycore.access.mcrimpl.MCRRuleMapping;
import org.mycore.access.mcrimpl.MCRRuleStore;
import org.mycore.common.MCRConfiguration;
import org.mycore.common.MCRSessionMgr;
import org.mycore.common.xml.MCRXMLHelper;
import org.mycore.user2.MCRUserMgr;

/**
 * This class holds useful methods for the workflow.
 * 
 * @author Heiko Helmbrecht, Anja Schaar, Robert Stephan
 * @version $Revision$ $Date$
 * 
 */
public class MCRWorkflowAccessRuleEditorUtils { 
	private static Logger logger = Logger
			.getLogger(MCRWorkflowAccessRuleEditorUtils.class.getName());
	private static MCRRuleStore rstore = MCRRuleStore.getInstance();
	private static String[] defaultRules = new String[]{};
	public  static final String RULEPREFIX = "DEFAULTRULE";
	private static final String NUMBERFORMAT="0000000000";
	public static final String EDITPOOL = "ruleeditor";
	
	protected static MCRConfiguration config = MCRConfiguration.instance();

	public final static void init(String oid){
		String defaultRuleString = config.getString("MCR.AccessRuleEditor.defaultrules");
		defaultRules = defaultRuleString.split(",");
		for(int i=0;i<defaultRules.length;i++){
			defaultRules[i]=defaultRules[i].trim();
		}		
		MCRAccessInterface AI = MCRAccessManager.getAccessImpl();
		if(AI.hasRule(oid, EDITPOOL)){
			//everything is O.K:
		}
		else{
			MCRAccessStore accessstore = MCRAccessStore.getInstance();
			MCRAccessControlSystem ACS = (MCRAccessControlSystem)MCRAccessControlSystem.instance();
			if(AI.hasRule(oid, "read")){
				String ruleID= accessstore.getRuleID(oid, "read");
				MCRRuleMapping rm = accessstore.getAccessDefinition(ruleID, MCRWorkflowAccessRuleEditorUtils.EDITPOOL, oid);
				rm.setPool(EDITPOOL);
				accessstore.createAccessDefinition(rm);
			}else{
				String strRule =config.getString("MCR.AccessRule.STANDARD-READ-RULE","<condition format=\"xml\"><boolean operator=\"true\" /></condition>");
				 Element rule = (Element)MCRXMLHelper.parseXML(strRule).getRootElement().detach();
				 MCRRuleMapping ruleMapping = ACS.getAutoGeneratedRuleMapping(rule, "RuleEditor", EDITPOOL, oid, "");
				 String oldRuleID = accessstore.getRuleID(oid, EDITPOOL);
				 if(oldRuleID == null || oldRuleID.equals("")) {
					 logger.debug("updateRule called for id <" + oid + "> and pool <" + EDITPOOL + ">, but no rule is existing, so new rule was created");
					 accessstore.createAccessDefinition(ruleMapping);
				}else{
					accessstore.updateAccessDefinition(ruleMapping);
				}
			}
		}
	}
	
	public final static void updateReadRule(String oid, String rulename, String[] parameter){
		boolean isValidRulename=false;
		for(int i=0;i<defaultRules.length;i++){
			if(rulename.equals(defaultRules[i])){ 
				isValidRulename=true;
				break;
			}
		}
		if(!isValidRulename) return;
		
		MCRAccessControlSystem ACS = (MCRAccessControlSystem)MCRAccessControlSystem.instance();
		String rawRuleString = config.getString("MCR.AccessRuleEditor.defaultrules."+rulename);
		String rule="";
		Element eRule=null;
		try{
			SAXBuilder builder = new SAXBuilder();
			eRule = builder.build(new StringReader(rawRuleString)).getRootElement();
			if(rulename.equals("groups")){
				XPath x = XPath.newInstance(".//condition[@value='${group}']");
				Element e = (Element)x.selectSingleNode(eRule); 
				if(e!=null && parameter!=null && !parameter.equals("")){
					Element p = e.getParentElement();
					p.removeChildren(e.getName());
					for(int i=0;i<parameter.length;i++){
						e = (Element) e.clone();
						logger.info(i+": "+parameter[i]);
						e.setAttribute("value", parameter[i]);
						p.addContent(e);
					}
				}
			}
			
			
			
			rule=ACS.getNormalizedRuleString(eRule);
			} catch(Exception e) {
			  logger.debug("Error parsing Condition from Properties (MCR.AccessRuleEditor.defaultrules.)"+rulename, e);
			  return;
			}	
		
		ArrayList ruleIDs = rstore.retrieveRuleIDs(rule,"");
/* entferne alle nicht durch den Ruleeditor erzeugten regeln */
		Iterator it = ruleIDs.iterator();
		while(it.hasNext()){
			if(!((String)it.next()).startsWith(RULEPREFIX+"_"+rulename.toUpperCase())){ it.remove();}
		}

		if(ruleIDs.size()==0){
			// if the rule does not exist - create new one and give it a special
			// name, to be able to distinguish it
			// MCRAccessManager will later pickup this rule and use it
			DecimalFormat nrFormat = new DecimalFormat(NUMBERFORMAT);
			
			String ruleID = RULEPREFIX+"_"+rulename.toUpperCase()+"_"+nrFormat.format(rstore.getNextFreeRuleID(RULEPREFIX+"_"+rulename.toUpperCase()+"_"));
			// (String id, String creator, Date creationTime, String rule,
			// String description)
			MCRAccessRule mcrARule = new MCRAccessRule(ruleID, "RuleEditor", new Date(), rule, "");
			rstore.createRule(mcrARule);
			ruleIDs = rstore.retrieveRuleIDs(rule, "");
			//delete all rules not created by editor
			it = ruleIDs.iterator();
			while(it.hasNext()){
				if(!((String)it.next()).startsWith(RULEPREFIX+"_"+rulename.toUpperCase())){ it.remove();}
			}
		}

		// reimplementation of to change creator
		// MCRAccessManager.updateRule(mcrOID,EDITPOOL,eCond, "");
		MCRAccessStore accessStore = MCRAccessStore.getInstance();
		String pool=EDITPOOL;
		MCRRuleMapping ruleMapping = ACS.getAutoGeneratedRuleMapping(eRule, "RuleEditor", pool, oid, "");
		String oldRuleID = accessStore.getRuleID(oid, pool);
		if(oldRuleID == null || oldRuleID.equals("")) {
			logger.debug("updateRule called for id <" + oid + "> and pool <" + pool + ">, but no rule is existing, so new rule was created");
			accessStore.createAccessDefinition(ruleMapping);
		}else{
			accessStore.updateAccessDefinition(ruleMapping);
		}
	
		
		
 	}
	
	public static String[] getDefaultRules(){
		return defaultRules;
	}
	
	public static String getCurrentRule(String oid){
		try{
			Element eRule = MCRAccessManager.getAccessImpl().getRule(oid, EDITPOOL);
		MCRAccessControlSystem ACS = (MCRAccessControlSystem)MCRAccessControlSystem.instance();
		String rule = ACS.getNormalizedRuleString(eRule);
		if(!rule.startsWith("(")){rule="("+rule+")";}
		ArrayList ruleIDs = rstore.retrieveRuleIDs(rule,"");
		if(ruleIDs.size()==0){ return "";}
		String ruleID = ((String)ruleIDs.get(0)).split("_")[1];
		return ruleID;
		}
		catch(Exception e){
			return "";
		}
		
	}
	
	public static void fillRulesCombobox(String currentRule, JspWriter out) {
		String lang = MCRSessionMgr.getCurrentSession().getCurrentLanguage();
		String[] rules = MCRWorkflowAccessRuleEditorUtils.getDefaultRules();
		for (int i = 0; i < rules.length; i++) {
			try {
				out.write("<option value=\"" + rules[i] + "\"");
				if (currentRule.equalsIgnoreCase(rules[i])) {
					out.write(" selected=\"selected\"");
				}
				out.write(">");
				out.write(PropertyResourceBundle.getBundle("messages",
						new Locale(lang)).getString(
						"MCR.AccessRuleEditor.defaultrules." + rules[i]));
			} catch (IOException e) {
				logger.debug("Could not create content for rules combobox", e);
			}
		}
	}
	
	
	public static void fillGroupsListbox(String mcrid, JspWriter out){
		try{
			String[] availGroups = MCRWorkflowAccessRuleEditorUtils.getAvailableGroups();
			String[] selectedGroups = MCRWorkflowAccessRuleEditorUtils.getSelectedGroups(mcrid);
			for(int i=0;i<availGroups.length;i++){
				out.write("<option value=\""+availGroups[i]+"\"");
				if(java.util.Arrays.asList(selectedGroups).contains(availGroups[i])){
					out.write(" selected=\"selected\"");
				}	
				out.write(">");
				out.write(availGroups[i]);
			}
		} catch(IOException e){
			logger.debug("Could not fill group listbox", e);
		}
	}
	
	private static String[] getAvailableGroups(){
		String[] groups = (String[]) MCRUserMgr.instance().getAllGroupIDs().toArray(new String[]{});
		return groups;
	}
	
	private static String[] getSelectedGroups(String oid){
		try{
			Element eRule = MCRAccessManager.getAccessImpl().getRule(oid, EDITPOOL);
			List listR = XPath.selectNodes(eRule, ".//condition[@field='group']");
			ArrayList listResults = new ArrayList();
			for(int i=0;i<listR.size();i++){
				listResults.add(((Element)listR.get(i)).getAttributeValue("value"));
			}
			return (String[])listResults.toArray(new String[]{});
		}catch(Exception e){
			return new String[]{};
		}		
	}
	
}
